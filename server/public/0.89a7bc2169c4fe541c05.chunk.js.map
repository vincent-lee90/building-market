{"version":3,"sources":["E:/myProjects/building-market/src/app/mall/model/product.model.ts","E:/myProjects/building-market/node_modules/rxjs/_esm5/operators/switchMap.js.pre-build-optimizer.js","E:/myProjects/building-market/node_modules/rxjs/_esm5/add/operator/switchMap.js","E:/myProjects/building-market/node_modules/rxjs/_esm5/operator/switchMap.js"],"names":["__webpack_require__","d","__webpack_exports__","Product","SwitchMapOperator","project","resultSelector","this","prototype","call","subscriber","source","subscribe","switchMap_SwitchMapSubscriber","_super","Object","tslib_es6","SwitchMapSubscriber","destination","index","_next","value","result","error","_innerSub","innerSubscription","unsubscribe","add","subscribeToResult","_complete","closed","_unsubscribe","notifyComplete","innerSub","remove","isStopped","notifyNext","outerValue","innerValue","outerIndex","innerIndex","_tryNotifyNext","next","err","OuterSubscriber","Observable","switchMap","lift"],"mappings":"sDAAAA,EAAAC,EAAAC,EAAA,sBAAAC,IAAA,IAAAA,EAAA,oGC+DIC,EAAiD,WACjD,SAAAA,EAA2BC,EAASC,GAChCC,KAAKF,QAAUA,EACfE,KAAKD,eAAiBA,EAK1B,OAHAF,EAAkBI,UAAUC,KAAO,SAAUC,EAAYC,GACrD,OAAOA,EAAOC,UAAU,IAAIC,EAAoBH,EAAYH,KAAKF,QAASE,KAAKD,kBAE5EF,EAR2B,GAelCS,EAAmD,SAAUC,GAC7DC,OAAAC,EAAA,EAAAD,CAAUE,EAAqBH,GAC/B,SAAAG,EAA6BC,EAAab,EAASC,GAC/CQ,EAAOL,KAAKF,KAAMW,GAClBX,KAAKF,QAAUA,EACfE,KAAKD,eAAiBA,EACtBC,KAAKY,MAAQ,EAwDjB,OAtDAF,EAAoBT,UAAUY,MAAQ,SAAUC,GAC5C,IAAIC,EACAH,EAAQZ,KAAKY,QACjB,IACIG,EAASf,KAAKF,QAAQgB,EAAOF,GAEjC,MAAOI,GAEH,YADAhB,KAAKW,YAAYK,MAAMA,GAG3BhB,KAAKiB,UAAUF,EAAQD,EAAOF,IAElCF,EAAoBT,UAAUgB,UAAY,SAAUF,EAAQD,EAAOF,GAC/D,IAAIM,EAAoBlB,KAAKkB,kBACzBA,GACAA,EAAkBC,cAEtBnB,KAAKoB,IAAIpB,KAAKkB,kBAAoBV,OAAAa,EAAA,EAAAb,CAAkBR,KAAMe,EAAQD,EAAOF,KAE7EF,EAAoBT,UAAUqB,UAAY,WACtC,IAAIJ,EAAoBlB,KAAKkB,kBACxBA,IAAqBA,EAAkBK,QACxChB,EAAON,UAAUqB,UAAUpB,KAAKF,OAGxCU,EAAoBT,UAAUuB,aAAe,WACzCxB,KAAKkB,kBAAoB,MAE7BR,EAAoBT,UAAUwB,eAAiB,SAAUC,GACrD1B,KAAK2B,OAAOD,GACZ1B,KAAKkB,kBAAoB,KACrBlB,KAAK4B,WACLrB,EAAON,UAAUqB,UAAUpB,KAAKF,OAGxCU,EAAoBT,UAAU4B,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYP,GAC7F1B,KAAKD,eACLC,KAAKkC,eAAeJ,EAAYC,EAAYC,EAAYC,GAGxDjC,KAAKW,YAAYwB,KAAKJ,IAG9BrB,EAAoBT,UAAUiC,eAAiB,SAAUJ,EAAYC,EAAYC,EAAYC,GACzF,IAAIlB,EACJ,IACIA,EAASf,KAAKD,eAAe+B,EAAYC,EAAYC,EAAYC,GAErE,MAAOG,GAEH,YADApC,KAAKW,YAAYK,MAAMoB,GAG3BpC,KAAKW,YAAYwB,KAAKpB,IAEnBL,EA9D6B,CA+DtC2B,EAAA,GC1IFC,EAAA,EAAArC,UAAAsC,UC+CA,SAAAzC,EAAAC,GACA,OFO0BD,EEP1BA,EFOmCC,EEPnCA,EFQW,SAAmCK,GACtC,OAAOA,EAAOoC,KAAK,IAAI3C,EAAkBC,EAASC,MET1DC,MFOM,IAAoBF,EAASC","file":"0.89a7bc2169c4fe541c05.chunk.js","sourcesContent":["export class Product {\r\n  id?: string;\r\n  product_name: string;\r\n  product_intro?:string;\r\n  product_logo: string;\r\n  product_detail?:string;\r\n  current_price: string;\r\n  origin_price: any;\r\n  product_cat: string;\r\n  store_code: string;\r\n  store_name?:string;\r\n  store_address?:string;\r\n  img_detail_urls?:any;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// E:/myProjects/building-market/src/app/mall/model/product.model.ts","/** PURE_IMPORTS_START .._OuterSubscriber,.._util_subscribeToResult PURE_IMPORTS_END */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b)\n        if (b.hasOwnProperty(p))\n            d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nexport function switchMap(project, resultSelector) {\n    return function switchMapOperatorFunction(source) {\n        return source.lift(new SwitchMapOperator(project, resultSelector));\n    };\n}\nvar SwitchMapOperator = /*@__PURE__*/ (/*@__PURE__*/ function () {\n    function SwitchMapOperator(project, resultSelector) {\n        this.project = project;\n        this.resultSelector = resultSelector;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n    };\n    return SwitchMapOperator;\n}());\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nvar SwitchMapSubscriber = /*@__PURE__*/ (/*@__PURE__*/ function (_super) {\n    __extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project, resultSelector) {\n        _super.call(this, destination);\n        this.project = project;\n        this.resultSelector = resultSelector;\n        this.index = 0;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        this.add(this.innerSubscription = subscribeToResult(this, result, value, index));\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        this.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        if (this.resultSelector) {\n            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        else {\n            this.destination.next(innerValue);\n        }\n    };\n    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n        var result;\n        try {\n            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map \n\n\n\n// WEBPACK FOOTER //\n// E:/myProjects/building-market/node_modules/rxjs/_esm5/operators/switchMap.js.pre-build-optimizer.js","/** PURE_IMPORTS_START .._.._Observable,.._.._operator_switchMap PURE_IMPORTS_END */\nimport { Observable } from '../../Observable';\nimport { switchMap } from '../../operator/switchMap';\nObservable.prototype.switchMap = switchMap;\n//# sourceMappingURL=switchMap.js.map \n\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/myProjects/building-market/node_modules/rxjs/_esm5/add/operator/switchMap.js\n// module id = null\n// module chunks = ","/** PURE_IMPORTS_START .._operators_switchMap PURE_IMPORTS_END */\nimport { switchMap as higherOrderSwitchMap } from '../operators/switchMap';\n/* tslint:enable:max-line-length */\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nexport function switchMap(project, resultSelector) {\n    return higherOrderSwitchMap(project, resultSelector)(this);\n}\n//# sourceMappingURL=switchMap.js.map \n\n\n\n//////////////////\n// WEBPACK FOOTER\n// E:/myProjects/building-market/node_modules/rxjs/_esm5/operator/switchMap.js\n// module id = null\n// module chunks = "],"sourceRoot":"webpack:///"}